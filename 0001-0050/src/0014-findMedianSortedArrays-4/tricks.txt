容易想到，用两个指针标记中位数的位置，最开始指向两个输入的头。
将较小的丢弃，即较小的输入指针向右移动
只要丢弃的数量到1/2，那么指针指向的位置就是中位数。时间复杂度是O(n)
更好的是o(log(min(m,n)))的算法，划分数组
          left_part          |         right_part
    A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
    B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
保持i+j的数量为数组长度之和的1/2，假设左边的最大值在上面，用二分查找，找到最大的i，满足A[i-1]<B[j]，因为A[i-1]<A[i]，
所以左边的最大值为A[i-1]，右边的最小值，就是A[i]和B[j]的较小值，求出结果。
如果上面二分查找没找到，就表示左边的最大值在下面。有两种可能，一种是上面最小的值A[0]都比B[mid-0]大，我们开始的时候，将上面弄成长度较小的那一个数组。
这样中位数就是B[mid-0].
另外一种是上面的最大值A[m-1]都小于B[mid-(m-1)]，此时左边的最大值就在下面的B[mid-(m-1)]这里。